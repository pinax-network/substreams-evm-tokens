// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Events {
    #[prost(message, repeated, tag="1")]
    pub swaps: ::prost::alloc::vec::Vec<Swap>,
    #[prost(message, repeated, tag="2")]
    pub intializes: ::prost::alloc::vec::Vec<Initialize>,
    #[prost(message, repeated, tag="3")]
    pub pools_created: ::prost::alloc::vec::Vec<PoolCreated>,
}
// *
// In Uniswap v3, the `PoolCreated` event is emitted when a new liquidity pool is deployed by the factory,
// providing key parameters for the poolâ€™s configuration; for example, if a pool is established for USDC and USDT
// with a fee tier of 3000 (equating to a 0.30% fee) and a tick spacing of 60, the event will log the addresses for
// token0 and token1 (USDC and USDT, respectively), the fee of 3000, the tick spacing of 60, and the address of the
// newly created pool contract, thereby enabling users and applications to track and interact with the new pool.

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolCreated {
    /// -- transaction --
    #[prost(bytes="vec", tag="1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// -- call --
    #[prost(bytes="vec", optional, tag="2")]
    pub caller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// -- log --
    ///
    /// log.address (factory)
    #[prost(bytes="vec", tag="3")]
    pub contract: ::prost::alloc::vec::Vec<u8>,
    /// log.ordinal
    #[prost(uint64, tag="4")]
    pub ordinal: u64,
    /// -- event --
    #[prost(bytes="vec", tag="21")]
    pub token0: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="22")]
    pub token1: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="23")]
    pub pool: ::prost::alloc::vec::Vec<u8>,
    /// int24 (e.g., 60)
    #[prost(int32, tag="24")]
    pub tick_spacing: i32,
    /// uint24 (e.g., 3000 represents 0.30%)
    #[prost(uint64, tag="25")]
    pub fee: u64,
}
/// *
/// In Uniswap v3, the `initialize` function is a crucial setup step that configures a newly deployed pool
/// by setting its initial square root price (`sqrtPriceX96`) and corresponding tick value.
/// After the pool is created via the `PoolCreated` event, calling `initialize` establishes the starting price
/// and essential parameters, thereby enabling the pool to process swaps and support liquidity provisioning.
/// Without this initialization, the pool remains unconfigured and cannot operate properly.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Initialize {
    /// -- transaction --
    #[prost(bytes="vec", tag="1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// -- call --
    #[prost(bytes="vec", optional, tag="2")]
    pub caller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// -- log --
    ///
    /// log.address
    #[prost(bytes="vec", tag="3")]
    pub contract: ::prost::alloc::vec::Vec<u8>,
    /// log.ordinal
    #[prost(uint64, tag="4")]
    pub ordinal: u64,
    /// -- event --
    ///
    /// uint160
    #[prost(string, tag="21")]
    pub sqrt_price_x96: ::prost::alloc::string::String,
    /// int24
    #[prost(int32, tag="22")]
    pub tick: i32,
}
/// *
/// In Uniswap v3, the `Swap` event is emitted when a trade occurs in a liquidity pool.
/// It provides key details of the swap, including the address of the sender initiating the swap,
/// the recipient of the swapped tokens, and the amounts of token0 and token1 involved in the trade.
/// Additionally, the event logs updated state parameters such as the square root price (`sqrtPriceX96`),
/// current liquidity, and the tick after the swap, thereby reflecting the pool's state changes.
/// This event is essential for on-chain tracking of trades, liquidity dynamics, and price updates.
///
/// Price Calculation:
/// Uniswap V3 represents the current pool price using a square root price value, `sqrtPriceX96`,
/// stored as a Q64.96 fixed-point number (with 64 bits for the integer part and 96 bits for the fraction).
/// To compute the actual price of token0 in terms of token1, the value is squared and then divided by 2^192:
///
///       price = (sqrtPriceX96 * sqrtPriceX96) / 2^192
///
/// Conversely, to determine the price of token1 in terms of token0, take the reciprocal of the computed price.
///
/// This calculation method provides high precision and efficient on-chain computation of price ratios.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Swap {
    /// -- transaction --
    #[prost(bytes="vec", tag="1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// -- call --
    #[prost(bytes="vec", optional, tag="2")]
    pub caller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// -- log --
    ///
    /// log.address
    #[prost(bytes="vec", tag="3")]
    pub contract: ::prost::alloc::vec::Vec<u8>,
    /// log.ordinal
    #[prost(uint64, tag="4")]
    pub ordinal: u64,
    /// -- swap --
    ///
    /// address
    #[prost(bytes="vec", tag="21")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    /// address
    #[prost(bytes="vec", tag="22")]
    pub recipient: ::prost::alloc::vec::Vec<u8>,
    /// int256
    #[prost(string, tag="23")]
    pub amount0: ::prost::alloc::string::String,
    /// int256
    #[prost(string, tag="24")]
    pub amount1: ::prost::alloc::string::String,
    /// uint160
    #[prost(string, tag="25")]
    pub sqrt_price_x96: ::prost::alloc::string::String,
    /// uint128
    #[prost(string, tag="26")]
    pub liquidity: ::prost::alloc::string::String,
    /// int24
    #[prost(int32, tag="27")]
    pub tick: i32,
}
// @@protoc_insertion_point(module)
